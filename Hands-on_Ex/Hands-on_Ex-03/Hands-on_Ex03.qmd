---
title: "Hands-on Exercise 3: 1st Order Spatial Point Patterns Analysis Methods & 2nd Order Spatial Point Patterns Analysis Methods"
author: "Maaruni"
execute: 
  warning: false
date: 01/13/2024
date-modified: "`r Sys.Date()`"
---

Questions we would like to explore:

-   are the childcare centres in Singapore randomly distributed throughout the country?

-   if the answer is not, then the next logical question is where are the locations with higher concentration of childcare centres?

# Getting started

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

Please use this command in the console if unable to install maptools on mac:

```{r}
# install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

Reference: <https://stackoverflow.com/questions/77511849/i-have-obtained-some-error-trying-to-install-maptools-in-rstudio>

Reading the relevant spatial data:

```{r}
childcare_sf <- st_read("../../data/geospatial/ChildCareServices.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "../../data/geospatial", layer="CostalOutline")
```

```{r}
mpsz_sf <- st_read(dsn = "../../data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

### **Mapping the geospatial data sets**

After checking the referencing system of each geospatial data data frame, it is also useful for us to plot a map to show their spatial patterns.

```{r}
plot(sg_sf)
```

```{r}
plot(mpsz_sf)
```

Notice that all the geospatial layers are within the same map extend. This shows that their referencing system and coordinate values are referred to similar spatial context. This is very important in any geospatial analysis.

Alternatively, we can also prepare a pin map by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

Notice that at the interactive mode, **tmap** is using [**leaflet for R**](https://rstudio.github.io/leaflet/) API. The advantage of this interactive pin map is it allows us to navigate and zoom around the map freely. We can also query the information of each simple feature (i.e. the point) by clicking of them. Last but not least, you can also change the background of the internet map layer. Currently, three internet map layers are provided. They are: ESRI.WorldGrayCanvas, OpenStreetMap, and ESRI.WorldTopoMap. The default is ESRI.WorldGrayCanvas.

## **Geospatial Data wrangling**

Although simple feature data frame is gaining popularity again sp’s Spatial\* classes, there are, however, many geospatial analysis packages require the input geospatial data in sp’s Spatial\* classes. In this section, you will learn how to convert simple feature data frame to sp’s Spatial\* class.

### **Converting sf data frames to sp’s Spatial\* class**

The code chunk below uses [*as_Spatial()*](https://r4gdsa.netlify.app/chap04.html) of **sf** package to convert the three geospatial data from simple feature data frame to sp’s Spatial\* class.

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

Lets view the data generated:

```{r}
childcare
```

Personal observations: It has only 2 variables. Why is that so?

```{r}
mpsz
```

```{r}
sg
```

Notice that the geospatial data have been converted into their respective sp’s Spatial\* classes now.

### **Converting the Spatial\* class into generic sp format**

**spatstat** requires the analytical data in ***ppp*** object form. There is no direct way to convert a Spatial\* classes into ***ppp*** object. We need to convert the ***Spatial*** **classes**\* into ***Spatial*** object first.

The codes chunk below converts the Spatial\* classes into generic sp objects.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

Next, you should display the sp objects properties as shown below.

```{r}
childcare_sp
```

```{r}
sg_sp
```

### **Converting the generic sp format into spatstat’s ppp format**

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

Now, let us plot ***childcare_ppp*** and examine the different.

```{r}
plot(childcare_ppp)
```

```{r}
summary(childcare_ppp)
```

Notice the warning message about duplicates. In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are *simple*, that is, that the points cannot be coincident.

### **Handling duplicated points**

We can check the duplication in a ***ppp*** object by using the code chunk below.

```{r}
any(duplicated(childcare_ppp))
```

To count the number of co-indicence point, we will use the *multiplicity()* function as shown in the code chunk below.

```{r}
multiplicity(childcare_ppp)
```

If we want to know how many locations have more than one point event, we can use the code chunk below.

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

The output shows that there are 128 duplicated point events.

To view the locations of these duplicate point events, we will plot `childcare` data by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode('plot')
```

There are three ways to overcome this problem. The easiest way is to delete the duplicates. But, that will also mean that some useful point events will be lost.

The second solution is use *jittering*, which will add a small perturbation to the duplicate points so that they do not occupy the exact same space.

The third solution is to make each point “unique” and then attach the duplicates of the points to the patterns as **marks**, as attributes of the points. Then you would need analytical techniques that take into account these marks.

The code chunk below implements the jittering approach.

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

### **Creating *owin* object**

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.

The code chunk below is used to covert *sg* SpatialPolygon object into owin object of **spatstat**.

```{r}
sg_owin <- as(sg_sp, "owin")
```

The ouput object can be displayed by using *plot()* function

```{r}
plot(sg_owin)
```

and *summary()* function of Base R.

```{r}
summary(childcare_ppp)
```

Notice the warning message about duplicates. In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are *simple*, that is, that the points cannot be coincident.

### **Handling duplicated points**

We can check the duplication in a ***ppp*** object by using the code chunk below.

```{r}
any(duplicated(childcare_ppp))
```

To count the number of co-indicence point, we will use the *multiplicity()* function as shown in the code chunk below.

```{r}
multiplicity(childcare_ppp)
```

If we want to know how many locations have more than one point event, we can use the code chunk below.

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

The output shows that there are 128 duplicated point events.

To view the locations of these duplicate point events, we will plot `childcare` data by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode('plot')
```

There are three ways to overcome this problem. The easiest way is to delete the duplicates. But, that will also mean that some useful point events will be lost.

The second solution is use *jittering*, which will add a small perturbation to the duplicate points so that they do not occupy the exact same space.

The third solution is to make each point “unique” and then attach the duplicates of the points to the patterns as **marks**, as attributes of the points. Then you would need analytical techniques that take into account these marks.

The code chunk below implements the jittering approach.

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

### **Creating *owin* object**

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.

The code chunk below is used to covert *sg* SpatialPolygon object into owin object of **spatstat**.

```{r}
sg_owin <- as(sg_sp, "owin")
```

The ouput object can be displayed by using *plot()* function

```{r}
plot(sg_owin)
```

and *summary()* function of Base R.

### **Combining point events object and owin object**

In this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore by using the code chunk below.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

The output object combined both the point and polygon feature in one ppp object class as shown below.

```{r}
summary(childcareSG_ppp)
```

DIY: Using the method you learned in previous exercise, plot the newly derived childcareSG_ppp as shown below.

## **First-order Spatial Point Patterns Analysis**

In this section, you will learn how to perform first-order SPPA by using **spatstat** package. The hands-on exercise will focus on:

-   deriving **kernel density estimation (KDE)** layer for visualising and exploring the intensity of point processes,

-   performing **Confirmatory Spatial Point Patterns Analysis** by using **Nearest Neighbour** statistics.

### **Kernel Density Estimation**

In this section, you will learn how to compute the kernel density estimation (KDE) of childcare services in Singapore.

#### Computing kernel density estimation using automatic bandwidth selection method

The code chunk below computes a kernel density by using the following configurations of [*density()*](https://rdrr.io/cran/spatstat/man/density.ppp.html) of **spatstat**:

-   [*bw.diggle()*](https://rdrr.io/cran/spatstat/man/bw.diggle.html) automatic bandwidth selection method. Other recommended methods are [*bw.CvL()*](https://rdrr.io/cran/spatstat/man/bw.CvL.html), [*bw.scott()*](https://rdrr.io/cran/spatstat/man/bw.scott.html) or [*bw.ppl()*](https://rdrr.io/cran/spatstat/man/bw.ppl.html).

-   The smoothing kernel used is *gaussian*, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.

-   The intensity estimate is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is *FALSE*.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

The *plot()* function of Base R is then used to display the kernel density derived.

```{r}
plot(kde_childcareSG_bw)
```

The density values of the output range from 0 to 0.000035 which is way too small to comprehend. This is because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of points per square meter”.

Before we move on to next section, it is good to know that you can retrieve the bandwidth used to compute the kde layer by using the code chunk below.

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

#### Rescalling KDE values

In the code chunk below, *rescale()* is used to covert the unit of measurement from meter to kilometer.

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

Now, we can re-run *density()* using the resale data set and plot the output kde map.

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

Notice that output image looks identical to the earlier version, the only changes in the data values (refer to the legend).

### **Working with different automatic badwidth methods**

Beside *bw.diggle()*, there are three other **spatstat** functions can be used to determine the bandwidth, they are: *bw.CvL()*, *bw.scott()*, and *bw.ppl()*.

Let us take a look at the bandwidth return by these automatic bandwidth calculation methods by using the code chunk below.

```{r}
 bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

Baddeley et. (2016) suggested the use of the *bw.ppl()* algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the *bw.diggle()* method seems to work best.

The code chunk beow will be used to compare the output of using *bw.diggle* and *bw.ppl* methods.

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### **Working with different kernel methods**

By default, the kernel method used in *density.ppp()* is *gaussian*. But there are three other options, namely: Epanechnikov, Quartic and Dics.

The code chunk below will be used to compute three more kernel density estimations by using these three kernel function.

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")

```

## **Fixed and Adaptive KDE**

### **Computing KDE by using fixed bandwidth**

Next, you will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of ***childcareSG_ppp.km*** object is in kilometer, hence the 600m is 0.6km.

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

### **Computing KDE by using adaptive bandwidth**

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

In this section, you will learn how to derive adaptive kernel density estimation by using [*density.adaptive()*](https://rdrr.io/cran/spatstat/man/adaptive.density.html) of **spatstat**.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

We can compare the fixed and adaptive kernel density estimation outputs by using the code chunk below.

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

### **Converting KDE output into grid object.**

The result is the same, we just convert it so that it is suitable for mapping purposes

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

#### Converting gridded output into raster

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

Let us take a look at the properties of *kde_childcareSG_bw_raster* RasterLayer.

```{r}
kde_childcareSG_bw_raster
```

Notice that the crs property is NA.

#### Assigning projection systems

The code chunk below will be used to include the CRS information on kde_childcareSG_bw_raster RasterLayer.

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

Notice that the crs property is completed.

### **Visualising the output in tmap**

Finally, we will display the raster in cartographic quality map using **tmap** package.

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

Notice that the raster values are encoded explicitly onto the raster pixel using the values in “v”” field.

### **Comparing Spatial Point Patterns using KDE**

In this section, you will learn how to compare KDE of childcare at Ponggol, Tampines, Chua Chu Kang and Jurong West planning areas.

#### Extracting study area

The code chunk below will be used to extract the target planning areas.

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

Plotting target planning areas

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

#### Converting the spatial point data frame into generic sp format

Next, we will convert these SpatialPolygonsDataFrame layers into generic spatialpolygons layers.

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

#### Creating ***owin*** object

Now, we will convert these SpatialPolygons objects into owin objects that is required by **spatstat**.

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")

```

#### Combining childcare points and the study area

By using the code chunk below, we are able to extract childcare that is within the specific region to do our analysis later on.

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Next, *rescale()* function is used to trasnform the unit of measurement from metre to kilometre.

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

The code chunk below is used to plot these four study areas and the locations of the childcare centres.

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### Computing KDE

The code chunk below will be used to compute the KDE of these four planning area. ***bw.diggle*** method is used to derive the bandwidth of each

```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

#### Computing fixed bandwidth KDE

For comparison purposes, we will use 250m as the bandwidth.

```{r}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

## **Nearest Neighbour Analysis**

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using [*clarkevans.test()*](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat**.

The test hypotheses are:

Ho = The distribution of childcare services are randomly distributed.

H1= The distribution of childcare services are not randomly distributed.

The 95% confident interval will be used.

### **Testing spatial point patterns using Clark and Evans Test**

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

What conclusion can you draw from the test result?

### **Clark and Evans Test: Choa Chu Kang planning area**

In the code chunk below, [*clarkevans.test()*](https://rdrr.io/cran/spatstat/man/clarkevans.test.html) of **spatstat** is used to performs Clark-Evans test of aggregation for childcare centre in Choa Chu Kang planning area.

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

### **Clark and Evans Test: Tampines planning area**

In the code chunk below, the similar test is used to analyse the spatial point patterns of childcare centre in Tampines planning area.

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

# 

# **7  Network Constrained Spatial Point Patterns Analysis**

## **7.1 Overview**

**Network constrained Spatial Point Patterns Analysis (NetSPAA)** is a collection of spatial point patterns analysis methods special developed for analysing spatial point event occurs on or alongside network. The spatial point event can be locations of traffic accident or childcare centre for example. The network, on the other hand can be a road network or river network.

In this hands-on exercise, you are going to gain hands-on experience on using appropriate functions of **spNetwork** package:

-   to derive **network constrained kernel density estimation (NetKDE)**, and

-   to perform network G-function and k-function analysis

## **7.2 The Data**

In this study, we will analyse the spatial distribution of childcare centre in [Punggol planning area](https://en.wikipedia.org/wiki/Punggol). For the purpose of this study, two geospatial data sets will be used. They are:

-   *Punggol_St*, a line features geospatial data which store the road network within Punggol Planning Area.

-   *Punggol_CC*, a point feature geospatial data which store the location of childcare centres within Punggol Planning Area.

Both data sets are in ESRI shapefile format.

## **7.3 Installing and launching the R packages**

In this hands-on exercise, four R packages will be used, they are:

-   [spNetwork](https://cran.r-project.org/web/packages/spNetwork/), which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It also can be used to build spatial matrices (‘listw’ objects like in ‘spdep’ package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances.

-   [rgdal](https://cran.r-project.org/web/packages/rgdal/), which provides bindings to the [‘Geospatial’ Data Abstraction Library (GDAL) (\>= 1.11.4)](https://gdal.org/) and access to projection/transformation operations from the [PROJ](https://proj.org/) library. In this exercise, rgdal will be used to import geospatial data in R and store as [sp](https://cran.r-project.org/web/packages/sp/vignettes/intro_sp.pdf) objects.

-   [sp](https://cran.r-project.org/web/packages/sp/), which provides classes and methods for dealing with spatial data in R. In this exercise, it will be used to manage SpatialPointsDataFrame and SpatiaLinesDataFrame, and for performing projection transformation.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/) which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.

Use the code chunk below to install and launch the four R packages.

```{r}
pacman::p_load(sp, sf, rgdal, spNetwork, tmap)
```

## **7.4 Data Import and Preparation**

The code chunk below uses `st_read()` of **sf** package to important Punggol_St and Punggol_CC geospatial data sets into RStudio as sf data frames.

```{r}
network <- st_read(dsn="../../data/geospatial", 
                   layer="Punggol_St")
```

```{r}
childcare <- st_read(dsn="../../data/geospatial",
                     layer="Punggol_CC")
```

We can examine the structure of the output SpatialDataFrame in RStudio. Alternative, code chunk below can be used to print the content of network SpatialLineDataFrame and childcare SpatialPointsDataFrame by using the code chunk below.

```{r}
str(network)
str(childcare)
```

When I exploring spNetwork’s functions, it came to my attention that spNetwork is expecting the geospatial data contains complete CRS information.

In the code chunk below, *spTransform()* of **sp** package is used to assign EPSG code to the SpatialDataFrames. The [epsg:3414](https://epsg.io/3414) is the code for svy21.

```{r}
#childcare <-spTransform(childcare,
#                        CRS("+init=epsg:3414"))
#network <- spTransform(network,
#                       CRS("+init=epsg:3414"))
```

## **7.5 Visualising the Geospatial Data**

Before we jump into the analysis, it is a good practice to visualise the geospatial data. There are at least two ways to visualise the geospatial data. One way is by using *plot()* of Base R as shown in the code chunk below.

```{r}
plot(network)
plot(childcare,add=T,col='red',pch = 19)
```

![](https://r4gdsa.netlify.app/chap07_files/figure-html/unnamed-chunk-5-1.png)

To visualise the geospatial data with high cartographic quality and interactive manner, the mapping function of **tmap** package can be used as shown in the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare) + 
  tm_dots() + 
  tm_shape(network) +
  tm_lines()
```

```{r}
tmap_mode('plot')
```

## **7.6 Network Constrained KDE (NetKDE) Analysis**

In this section, we will perform NetKDE analysis by using appropriate functions provided in **spNetwork** package.

### **7.6.1 Preparing the lixels objects**

Before computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with *lixelize_lines()* of spNetwork as shown in the code chunk below.

```{r}
lixels <- lixelize_lines(network, 
                         700, 
                         mindist = 350)
```

What can we learned from the code chunk above:

-   The length of a lixel, *lx_length* is set to 700m, and

-   The minimum length of a lixel, *mindist* is set to 350m.

After cut, if the length of the final lixel is shorter than the minimum distance, then it is added to the previous lixel. If NULL, then mindist = maxdist/10. Also note that the segments that are already shorter than the minimum distance are not modified

**Note:** There is another function called *lixelize_lines.mc()* which provide multicore support.

### **7.6.2 Generating line centre points**

Next, *lines_center()* of **spNetwork** will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points as shown in the code chunk below.

```{r}
samples <- lines_center(lixels)
```

The points are located at center of the line based on the length of the line.

### **7.6.3 Performing NetKDE**

We are ready to computer the NetKDE by using the code chunk below.

```{r}
densities <- nkde(network, 
                  events = childcare,
                  w = rep(1,nrow(childcare)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

What can we learn from the code chunk above?

-   *kernel_name* argument indicates that **quartic** kernel is used. Are possible kernel methods supported by spNetwork are: triangle, gaussian, scaled gaussian, tricube, cosine ,triweight, epanechnikov or uniform.

-   *method* argument indicates that **simple** method is used to calculate the NKDE. Currently, spNetwork support three popular methods, they are:

    -   method=“simple”. This first method was presented by Xie et al. (2008) and proposes an intuitive solution. The distances between events and sampling points are replaced by network distances, and the formula of the kernel is adapted to calculate the density over a linear unit instead of an areal unit.

    -   method=“discontinuous”. The method is proposed by Okabe et al (2008), which equally “divides” the mass density of an event at intersections of lixels.

    -   method=“continuous”. If the discontinuous method is unbiased, it leads to a discontinuous kernel function which is a bit counter-intuitive. Okabe et al (2008) proposed another version of the kernel, that divide the mass of the density at intersection but adjusts the density before the intersection to make the function continuous.

The user guide of **spNetwork** package provide a comprehensive discussion of *nkde()*. You should read them at least once to have a basic understanding of the various parameters that can be used to calibrate the NetKDE model.

#### 7.6.3.1 Visualising NetKDE

Before we can visualise the NetKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into *samples* and *lixels* objects as *density* field.

```{r}
samples$density <- densities
lixels$density <- densities
```

Since svy21 projection system is in meter, the computed density values are very small i.e. 0.0000005. The code chunk below is used to resale the density values from number of events per meter to number of events per kilometer.

```{r}
# rescaling to help the mapping
samples$density <- samples$density*1000
lixels$density <- lixels$density*1000
```

The code below uses appropriate functions of tmap package to prepare interactive and high cartographic quality map visualisation.

```{r}
tmap_mode('view')
tm_shape(lixels)+
  tm_lines(col="density")+
tm_shape(childcare)+
  tm_dots()

```

```{r}
tmap_mode('plot')
```

The interactive map above effectively reveals road segments (darker color) with relatively higher density of childcare centres than road segments with relatively lower density of childcare centres (lighter color)

## **7.7 Network Constrained G- and K-Function Analysis**

In this section, we are going to perform complete spatial randomness (CSR) test by using *kfunctions()* of **spNetwork** package. The null hypothesis is defined as:

**Ho: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a street network in Punggol Planning Area.**

The CSR test is based on the assumption of the binomial point process which implies the hypothesis that the childcare centres are randomly and independently distributed over the street network.

If this hypothesis is rejected, we may infer that the distribution of childcare centres are spatially interacting and dependent on each other; as a result, they may form nonrandom patterns.

```{r}
kfun_childcare <- kfunctions(network, 
                             childcare,
                             start = 0, 
                             end = 1000, 
                             step = 50, 
                             width = 50, 
                             nsim = 50, 
                             resolution = 50,
                             verbose = FALSE, 
                             conf_int = 0.05)
```

What can we learn from the code chunk above?

There are ten arguments used in the code chunk above they are:

-   lines: A SpatialLinesDataFrame with the sampling points. The geometries must be a SpatialLinesDataFrame (may crash if some geometries are invalid).

-   points: A SpatialPointsDataFrame representing the points on the network. These points will be snapped on the network.

-   start: A double, the start value for evaluating the k and g functions.

-   end: A double, the last value for evaluating the k and g functions.

-   step: A double, the jump between two evaluations of the k and g function.

-   width: The width of each donut for the g-function.

-   nsim: An integer indicating the number of Monte Carlo simulations required. In the above example, 50 simulation was performed. **Note:** most of the time, more simulations are required for inference

-   resolution: When simulating random points on the network, selecting a resolution will reduce greatly the calculation time. When resolution is null the random points can occur everywhere on the graph. If a value is specified, the edges are split according to this value and the random points are selected vertices on the new network.

-   conf_int: A double indicating the width confidence interval (default = 0.05).

For the usage of other arguments, you should refer to the user guide of **spNetwork** package.

The output of *kfunctions()* is a list with the following values:

-   *plotkA*, a ggplot2 object representing the values of the k-function

-   *plotgA*, a ggplot2 object representing the values of the g-function

-   *valuesA*, a DataFrame with the values used to build the plots

For example, we can visualise the ggplot2 object of k-function by using the code chunk below.

```{r}
kfun_childcare$plotk
```

The blue line is the empirical network K-function of the childcare centres in Punggol planning area. The gray envelop represents the results of the 50 simulations in the interval 2.5% - 97.5%. Because the blue line between the distance of 250m-400m are below the gray area, we can infer that the childcare centres in Punggol planning area resemble regular pattern at the distance of 250m-400m.

### References

-   <https://r4gdsa.netlify.app/chap07.html#installing-and-launching-the-r-packages>
